# Nombre del workflow de CI/CD
name: CI/CD Pipeline para Hello-World FastAPI

# Eventos que disparan el workflow
on:
  push:
    branches:
      - main # Se ejecuta cuando se suben cambios a la rama 'main'
  pull_request:
    branches:
      - main # Se ejecuta cuando se crea un Pull Request contra la rama 'main'

# Definición de los jobs (tareas) del pipeline
jobs:
  # Job para el análisis de código (Linting)
  lint:
    name: Lint Code
    runs-on: ubuntu-latest # Se ejecuta en un runner de Ubuntu
    
    steps:
    - name: Checkout repository code
      uses: actions/checkout@v3 # Descarga el código del repositorio
    
    - name: Set up Python 3.11
      uses: actions/setup-python@v4 # Configura el entorno Python
      with:
        python-version: '3.11' # Versión de Python a usar
        
    - name: Install dependencies for linting
      run: |
        python -m pip install --upgrade pip # Actualiza pip
        pip install flake8 black isort # Instala herramientas de linting y formateo
        pip install -r requirements.txt # Instala las dependencias del proyecto
        
    - name: Run Flake8 linter
      run: |
        flake8 . --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics
        
    - name: Check code formatting with Black
      run: |
        black --check . # Verifica que el código cumpla con el formato de Black
        
    - name: Check import order with Isort
      run: |
        isort --check-only --profile black . # Verifica el orden de las importaciones

  # Job para ejecutar pruebas unitarias
  test:
    name: Run Tests
    runs-on: ubuntu-latest # Se ejecuta en un runner de Ubuntu
    needs: lint # Este job depende del job 'lint', solo se ejecuta si 'lint' es exitoso
    
    steps:
    - name: Checkout repository code
      uses: actions/checkout@v3 # Descarga el código del repositorio
    
    - name: Set up Python 3.11
      uses: actions/setup-python@v4 # Configura el entorno Python
      with:
        python-version: '3.11'
        
    - name: Install dependencies for testing
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt # Instala las dependencias del proyecto
        pip install pytest pytest-cov # Instala herramientas de testing
        
    - name: Run Pytest tests
      run: |
        pytest # Ejecuta las pruebas unitarias

  # Job para construir la imagen Docker y desplegar en Google Cloud Run
  build-and-deploy:
    name: Build and Deploy to Cloud Run
    needs: test # Este job depende del job 'test', solo se ejecuta si 'test' es exitoso
    runs-on: ubuntu-latest # Se ejecuta en un runner de Ubuntu
    
    # IMPORTANTE: Asocia este job con tu ambiente de GitHub.
    # Esto permite acceder a los secretos de ambiente como 'SA_MLCATALOGDEV'.
    environment: ci-cd 
    
    steps:
    - name: Checkout repository code
      uses: actions/checkout@v3 # Descarga el código del repositorio
    
    - id: 'auth'
      name: 'Authenticate to Google Cloud'
      uses: 'google-github-actions/auth@v1' # Acción para autenticarse con GCP
      with:
        # Usa el nombre del secreto que creaste en tu ambiente 'ci-cd' en GitHub.
        # Este secreto debe contener el JSON de la clave de tu cuenta de servicio.
        credentials_json: '${{ secrets.SA_MLCATALOGDEV }}' 
    
    - name: 'Set up Google Cloud SDK'
      uses: 'google-github-actions/setup-gcloud@v1' # Configura gcloud CLI
      with:
        # Define explícitamente el ID de tu proyecto de GCP para todos los comandos gcloud.
        project_id: crp-dev-dig-mlcatalog 
        
    # Paso para construir y subir la imagen Docker usando Google Cloud Build
    - name: 'Build and Push Image with Cloud Build'
      # Añadir 'set -e' para que el script falle inmediatamente si algún comando no es exitoso
      run: |
        set -e 
        
        # Obtiene el SHA corto del commit actual para versionar la imagen.
        SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
        
        # Define las variables de tu imagen y registro.
        IMAGE_NAME="hello-world-fastapi"
        PROJECT_ID="crp-dev-dig-mlcatalog" # Tu ID de proyecto de GCP
        REGION="us-central1" # La región donde está tu Artifact Registry
        REGISTRY_NAME="cicd" # El nombre de tu repositorio en Artifact Registry
        
        # Construye la ruta completa de la imagen para el registro.
        IMAGE_FULL_PATH="${REGION}-docker.pkg.dev/${PROJECT_ID}/${REGISTRY_NAME}/${IMAGE_NAME}"
        TAG_VERSION="${IMAGE_FULL_PATH}:${SHORT_SHA}" # Etiqueta con la versión del commit
        TAG_LATEST="${IMAGE_FULL_PATH}:latest" # Etiqueta como 'latest'
        
        echo "Building and pushing image to $TAG_VERSION and $TAG_LATEST using Cloud Build..."
        
        # Ejecuta gcloud builds submit para enviar el código a Cloud Build.
        # Esto iniciará el build en GCP.
        gcloud builds submit . \
          --tag=$TAG_VERSION \
          --tag=$TAG_LATEST \
          --project=$PROJECT_ID \
          --timeout=10m 

        # Guarda el tag de la versión en una variable de entorno de GitHub Actions
        echo "IMAGE_TAG=$TAG_VERSION" >> $GITHUB_ENV
    
    # Paso para desplegar la imagen en Cloud Run
    - name: 'Deploy to Cloud Run'
      # Añadir 'set -e' para que el script falle inmediatamente si algún comando no es exitoso
      run: |
        set -e 
        
        SERVICE_NAME="fastapi-hello-world-service"
        PROJECT_ID="crp-dev-dig-mlcatalog" # Tu ID de proyecto de GCP
        REGION="us-central1" # La región donde quieres desplegar tu servicio Cloud Run
        
        echo "Deploying service $SERVICE_NAME with image ${{ env.IMAGE_TAG }} to Cloud Run in $REGION..."
        
        # Ejecuta el comando de despliegue de Cloud Run.
        # La imagen se toma de Artifact Registry.
        gcloud run deploy $SERVICE_NAME \
          --image=${{ env.IMAGE_TAG }} \
          --region=$REGION \
          --platform=managed \
          --port=9819 \
          --cpu=4 \
          --memory=16Gi \
          --min-instances=1 \
          --max-instances=50 \
          --timeout=3600s \
          --concurrency=80 \
          --execution-environment=gen2 \
          --project=$PROJECT_ID \
          --no-allow-unauthenticated # Revisa si tu servicio debe ser público o no.
        
        echo "Deployed version ${{ env.IMAGE_TAG }} to $SERVICE_NAME"
